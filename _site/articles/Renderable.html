<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Better Renderable Types</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link href="http://cdn.jsdelivr.net/font-hack/2.010/css/hack.min.css" rel="stylesheet">
    <style type="text/css">
      h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
        font-family: Georgia, 'Times New Roman', serif;
      }
      .caption {
        font-size: smaller;
        font-style: italic;
      }
      .page-header {
          margin-top: 0px;
      }
      /* syntax highlighting */
      code {
        font-family: Hack, monospace;
      }
      table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre {
        margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none;
      }
      td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
      td.sourceCode { padding-left: 5px; }
      .sourceCode span.kw { color: #007020; font-weight: bold; }
      .sourceCode span.dt { color: #902000; }
      .sourceCode span.dv { color: #40a070; }
      .sourceCode span.bn { color: #40a070; }
      .sourceCode span.fl { color: #40a070; }
      .sourceCode span.ch { color: #4070a0; }
      .sourceCode span.st { color: #4070a0; }
      .sourceCode span.co { color: #60a0b0; font-style: italic; }
      .sourceCode span.ot { color: #007020; }
      .sourceCode span.al { color: red; font-weight: bold; }
      .sourceCode span.fu { color: #06287e; }
      .sourceCode span.re { }
      .sourceCode span.er { color: red; font-weight: bold; }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="row page-header">
        <div class="col-md-3">
            <h1><a href="../">Zyghost</a></h1>
            <a href="../articles.html">articles</a>
          &nbsp;
          &nbsp;
          <a href="https://github.com/schell"><i class="fa fa-github"></i></a>
          <a href="https://twitter.com/schellsan"><i class="fa fa-twitter"></i></a>
          <a href="https://instagram.com/schellsan/"><i class="fa fa-instagram"></i></a>
          <a href="https://www.facebook.com/likeaseashell"><i class="fa fa-facebook"></i></a>
        </div>
        <div class="col-md-9">
            <h1>Better Renderable Types</h1>
        </div>
      </div>

      <div class="row">
        <div class="content col-md-12">
          <div class="col-md-3" id="toc"> <h3>Table of Contents</h3> <ul>
<li><a href="#rendering">Rendering</a></li>
<li><a href="#primitive">Primitive</a></li>
<li><a href="#composite">Composite</a></li>
<li><a href="#rendering-a-frame">Rendering a frame</a></li>
<li><a href="#all-done">All done</a></li>
</ul> </div> <div class="col-md-9"><p>I’ve been working on a purely functional GUI and I realized that the structures I’ve been using for rendering could be easily abstracted out into a <a href="http://hackage.haskell.org/package/renderable">library</a>. The types may seem complex but the ideas are simple enough.</p>
<p>The main idea behind <code>renderable</code> is that all graphics can be broken down into primitives.</p>
<h3 id="rendering">Rendering</h3>
<p>A rendering is simply an effectful value that draws something on the screen in a specific place. Also needed is an effectful value that releases any resources allocated when creating the rendering. Since both values are created at the same time from here on out a “rendering” will be a <a href="http://hackage.haskell.org/package/renderable-0.1.0.0/docs/Data-Renderable.html#t:Rendering">tuple of the two</a>. So let’s dive into what we’ll be rendering.</p>
<h3 id="primitive">Primitive</h3>
<p>First off we have the typeclass <a href="http://hackage.haskell.org/package/renderable-0.1.0.0/docs/Data-Renderable.html#t:Primitive">Primitive</a>. A primitive is an atomic unit of “graphics”. In my current project I’ve chosen to render boxes, polylines and text. Each of these are a primitive that I’ll use in different combinations to create my interface. <code>Primitive</code> has three associated types - a monad, a transform type and a resource type. The monad represents the context of the primitive rendering calls themselves and in most cases will be the IO monad. If you’re using OpenGL you’ll probably use IO. The transform represents the kind of transformations you will apply to your primitives. I’m using a two dimensional affine transformation but you can use anything. It just represents how a rendering can be changed without having to alter the underlying resources.</p>
<p>Lastly the resource type is whatever datatype holds the resources needed to render primitives. This may be a record that holds shaders or references to windows, fonts, etc. For my current project I’m using a <code>Rez</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Rez</span> <span class="fu">=</span> <span class="dt">Rez</span> {<span class="ot"> rezGeom      ::</span> <span class="dt">GeomRenderSource</span>
               ,<span class="ot"> rezBez       ::</span> <span class="dt">BezRenderSource</span>
               ,<span class="ot"> rezMask      ::</span> <span class="dt">MaskRenderSource</span>
               ,<span class="ot"> rezWindow    ::</span> <span class="dt">Window</span>
               ,<span class="ot"> rezFont      ::</span> <span class="dt">Font</span>
               ,<span class="ot"> rezIcons     ::</span> <span class="dt">Font</span>
               } <span class="kw">deriving</span> (<span class="dt">Typeable</span>)</code></pre></div>
<p>Primitives must have Hashable instances - this is so they can be cached after being allocated. If you’re using OpenGL like I am then ‘allocation’ means making some IO calls in order to send geometry and other data to the GPU. The <a href="http://hackage.haskell.org/package/renderable-0.1.0.0/docs/Data-Renderable.html#v:compilePrimitive">compilePrimitive</a> function is where we run the initial IO calls to allocate resources for the datatype’s rendering and then return a tuple of the cleanup function and the draw function. Since all Primitive instances are also instances of Hashable the <code>renderable</code> package will automatically look up any needed renderings in the cache, create new ones and release stale ones without you having to think about it.</p>
<p>Here are some <code>Primitive</code> instances to give you an example - they use another (very) experimental project of mine called <a href="http://hackage.haskell.org/package/gelatin">gelatin</a>, which at this point is a thin wrapper around <a href="http://hackage.haskell.org/package/gl">gl</a> that provides some very specific things I need for my programs</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">--------------------------------------------------------------------------------</span>
<span class="co">-- Unit for fun</span>
<span class="fu">--------------------------------------------------------------------------------</span>
<span class="kw">instance</span> <span class="dt">Primitive</span> () <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">PrimM</span> () <span class="fu">=</span> <span class="dt">IO</span>
    <span class="kw">type</span> <span class="dt">PrimR</span>  () <span class="fu">=</span> <span class="dt">Rez</span>
    <span class="kw">type</span> <span class="dt">PrimT</span>  () <span class="fu">=</span> <span class="dt">Transform</span>
    compilePrimitive _ _ <span class="fu">=</span> return (return (), const <span class="fu">$</span> return ())
<span class="fu">--------------------------------------------------------------------------------</span>
<span class="co">-- Polyline</span>
<span class="fu">--------------------------------------------------------------------------------</span>
<span class="kw">instance</span> <span class="dt">Primitive</span> <span class="dt">Polyline</span> <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">PrimM</span> <span class="dt">Polyline</span> <span class="fu">=</span> <span class="dt">IO</span>
    <span class="kw">type</span> <span class="dt">PrimR</span>  <span class="dt">Polyline</span> <span class="fu">=</span> <span class="dt">Rez</span>
    <span class="kw">type</span> <span class="dt">PrimT</span>  <span class="dt">Polyline</span> <span class="fu">=</span> <span class="dt">Transform</span>
    compilePrimitive (<span class="dt">Rez</span> geom _ _ win _ _) <span class="dt">Polyline</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span>
        <span class="kw">let</span> fill <span class="fu">=</span> solid polylineColor
            p <span class="fu">=</span> polyline <span class="dt">EndCapSquare</span> <span class="dt">LineJoinMiter</span> polylineWidth polylinePath
        <span class="dt">Rendering</span> f c <span class="ot">&lt;-</span> filledTriangleRendering win geom p fill
        return (c, f)

<span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">Polyline</span> <span class="kw">where</span>
    hashWithSalt s <span class="dt">Polyline</span>{<span class="fu">..</span>} <span class="fu">=</span>
        s <span class="ot">`hashWithSalt`</span> polylineWidth
            <span class="ot">`hashWithSalt`</span> polylineColor
                <span class="ot">`hashWithSalt`</span> polylinePath

<span class="kw">data</span> <span class="dt">Polyline</span> <span class="fu">=</span> <span class="dt">Polyline</span> {<span class="ot"> polylineWidth     ::</span> <span class="dt">Float</span>
                         ,<span class="ot"> polylineColor     ::</span> <span class="dt">Color</span>
                         ,<span class="ot"> polylinePath      ::</span> [<span class="dt">V2</span> <span class="dt">Float</span>]
                         } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>, <span class="dt">Generic</span>)

<span class="ot">path2Polyline ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Polyline</span>
path2Polyline <span class="fu">=</span> <span class="dt">Polyline</span>
<span class="fu">--------------------------------------------------------------------------------</span>
<span class="co">-- Box</span>
<span class="fu">--------------------------------------------------------------------------------</span>
<span class="ot">boxPath ::</span> <span class="dt">Box</span> <span class="ot">-&gt;</span> <span class="dt">Path</span>
boxPath <span class="dt">Box</span>{<span class="fu">..</span>} <span class="fu">=</span> poly
    <span class="kw">where</span> poly <span class="fu">=</span> [<span class="dt">V2</span> x1 y1, <span class="dt">V2</span> x2 y1, <span class="dt">V2</span> x2 y2, <span class="dt">V2</span> x1 y2, <span class="dt">V2</span> x1 y1]
          (<span class="dt">V2</span> w h) <span class="fu">=</span> boxSize
          x1 <span class="fu">=</span> <span class="dv">0</span>
          x2 <span class="fu">=</span> w
          y1 <span class="fu">=</span> <span class="dv">0</span>
          y2 <span class="fu">=</span> h

<span class="ot">boxPolyline ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Box</span> <span class="ot">-&gt;</span> <span class="dt">Polyline</span>
boxPolyline lw <span class="dt">Box</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="dt">Polyline</span> lw boxColor path
    <span class="kw">where</span> path <span class="fu">=</span> [<span class="dt">V2</span> x1 y1, <span class="dt">V2</span> x2 y1, <span class="dt">V2</span> x2 y2, <span class="dt">V2</span> x1 y2, <span class="dt">V2</span> x1 y1]
          (<span class="dt">V2</span> w h) <span class="fu">=</span> boxSize
          x1 <span class="fu">=</span> <span class="fu">-</span>hw
          x2 <span class="fu">=</span> w <span class="fu">+</span> hw
          y1 <span class="fu">=</span> <span class="fu">-</span>hw
          y2 <span class="fu">=</span> h <span class="fu">+</span> hw
          hw <span class="fu">=</span> lw<span class="fu">/</span><span class="dv">2</span>

<span class="kw">data</span> <span class="dt">Box</span> <span class="fu">=</span> <span class="dt">Box</span> {<span class="ot"> boxSize      ::</span> <span class="dt">Size</span>
               ,<span class="ot"> boxColor     ::</span> <span class="dt">Color</span>
               } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">Box</span> <span class="kw">where</span>
    hashWithSalt s (<span class="dt">Box</span> sz c) <span class="fu">=</span> s <span class="ot">`hashWithSalt`</span> sz <span class="ot">`hashWithSalt`</span> c

<span class="kw">instance</span> <span class="dt">Primitive</span> <span class="dt">Box</span> <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">PrimM</span> <span class="dt">Box</span> <span class="fu">=</span> <span class="dt">IO</span>
    <span class="kw">type</span> <span class="dt">PrimR</span> <span class="dt">Box</span>  <span class="fu">=</span> <span class="dt">Rez</span>
    <span class="kw">type</span> <span class="dt">PrimT</span> <span class="dt">Box</span>  <span class="fu">=</span> <span class="dt">Transform</span>
    compilePrimitive (<span class="dt">Rez</span> geom _ _ win _ _) (<span class="dt">Box</span> (<span class="dt">V2</span> w h) c) <span class="fu">=</span> <span class="kw">do</span>
        <span class="kw">let</span> [tl, tr, br, bl] <span class="fu">=</span> [zero, <span class="dt">V2</span> w <span class="dv">0</span>, <span class="dt">V2</span> w h, <span class="dt">V2</span> <span class="dv">0</span> h]
            vs <span class="fu">=</span> [tl, tr, br, tl, br, bl]
            cs <span class="fu">=</span> replicate <span class="dv">6</span> c
        <span class="dt">Rendering</span> f c' <span class="ot">&lt;-</span> colorRendering win geom <span class="dt">GL_TRIANGLES</span> vs cs
        return (c',f)
<span class="fu">--------------------------------------------------------------------------------</span>
<span class="co">-- PlainText</span>
<span class="fu">--------------------------------------------------------------------------------</span>
<span class="kw">instance</span> <span class="dt">Primitive</span> <span class="dt">PlainText</span> <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">PrimM</span> <span class="dt">PlainText</span> <span class="fu">=</span> <span class="dt">IO</span>
    <span class="kw">type</span> <span class="dt">PrimR</span> <span class="dt">PlainText</span> <span class="fu">=</span> <span class="dt">Rez</span>
    <span class="kw">type</span> <span class="dt">PrimT</span> <span class="dt">PlainText</span> <span class="fu">=</span> <span class="dt">Transform</span>
    compilePrimitive (<span class="dt">Rez</span> geom bz _ win font _) (<span class="dt">PlainText</span> str fc) <span class="fu">=</span> <span class="kw">do</span>
        <span class="dt">Rendering</span> f c <span class="ot">&lt;-</span> stringRendering win geom bz font str fc (<span class="dv">0</span>,<span class="dv">0</span>)
        return (c,f)

<span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">PlainText</span> <span class="kw">where</span>
    hashWithSalt s <span class="dt">PlainText</span>{<span class="fu">..</span>} <span class="fu">=</span>
        s <span class="ot">`hashWithSalt`</span> plainTxtString <span class="ot">`hashWithSalt`</span> plainTxtColor

<span class="kw">data</span> <span class="dt">PlainText</span> <span class="fu">=</span> <span class="dt">PlainText</span> {<span class="ot"> plainTxtString ::</span> <span class="dt">String</span>
                           ,<span class="ot"> plainTxtColor  ::</span> <span class="dt">Color</span>
                           } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)</code></pre></div>
<h3 id="composite">Composite</h3>
<p><a href="http://hackage.haskell.org/package/renderable-0.1.0.0/docs/Data-Renderable.html#t:Composite">The next step up in abstraction</a> applies when you have described some adequate number of primitive types. From here on up you can graphically represent new types as a heterogeneous list of those more primitive types. <a href="http://hackage.haskell.org/package/renderable-0.0.0.2/docs/Data-Renderable.html#t:Element">Element</a> is used to package those primitive types in a list. <code>composite</code> simply takes your type and “decomposes” it into transformed Primitive elements.</p>
<p>This is where making new renderings gets really easy</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">--------------------------------------------------------------------------------</span>
<span class="co">-- TextInput</span>
<span class="fu">--------------------------------------------------------------------------------</span>
<span class="kw">data</span> <span class="dt">TextInput</span> <span class="fu">=</span> <span class="dt">TextInput</span> {<span class="ot"> textInputTransform ::</span> <span class="dt">Transform</span>
                           ,<span class="ot"> textInputText      ::</span> <span class="dt">PlainText</span>
                           ,<span class="ot"> textInputBox       ::</span> <span class="dt">Box</span>
                           ,<span class="ot"> textInputActive    ::</span> <span class="dt">Bool</span>
                           } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>)

<span class="ot">localTextInputPath ::</span> <span class="dt">TextInput</span> <span class="ot">-&gt;</span> <span class="dt">Path</span>
localTextInputPath <span class="fu">=</span> boxPath <span class="fu">.</span> textInputBox

<span class="ot">globalTextInputPath ::</span> <span class="dt">TextInput</span> <span class="ot">-&gt;</span> <span class="dt">Path</span>
globalTextInputPath t<span class="fu">@</span><span class="dt">TextInput</span>{<span class="fu">..</span>} <span class="fu">=</span>
    transformPoly textInputTransform <span class="fu">$</span> localTextInputPath t

<span class="ot">textInputOutline ::</span> <span class="dt">TextInput</span> <span class="ot">-&gt;</span> <span class="dt">Polyline</span>
textInputOutline t<span class="fu">@</span><span class="dt">TextInput</span>{<span class="fu">..</span>} <span class="fu">=</span> path2Polyline <span class="dv">1</span> white <span class="fu">$</span> localTextInputPath t

<span class="kw">instance</span> <span class="dt">Composite</span> <span class="dt">TextInput</span> <span class="dt">IO</span> <span class="dt">Rez</span> <span class="dt">Transform</span> <span class="kw">where</span>
    composite txt<span class="fu">@</span><span class="dt">TextInput</span>{<span class="fu">..</span>} <span class="fu">=</span>
        [ (textInputTransform, <span class="dt">Element</span> textInputBox)
        , (textInputTransform, <span class="dt">Element</span> textInputText)
        ] <span class="fu">++</span> [(textInputTransform, <span class="dt">Element</span> poly) <span class="fu">|</span> textInputActive]
            <span class="kw">where</span> poly <span class="fu">=</span> textInputOutline txt</code></pre></div>
<h3 id="rendering-a-frame">Rendering a frame</h3>
<p>After you have some datatypes to render from primitives it’s dead simple to get them on the screen. All your loop has to keep around is the current data to render and the last rendering cache. Then you can use <a href="http://hackage.haskell.org/package/renderable-0.1.0.0/docs/Data-Renderable.html#v:renderData">renderData</a> to render your data to the screen. Here is an example of the function I’m using to render to the screen. There’s only three relevant lines and the rest is GLFW noise</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">renderFrame ::</span> <span class="dt">Workspace</span> <span class="ot">-&gt;</span> <span class="dt">UI</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Workspace</span>
renderFrame ws ui <span class="fu">=</span> <span class="kw">do</span>
        <span class="co">-- Get the Rez (resource type)</span>
    <span class="kw">let</span> rz  <span class="fu">=</span> wsRez ws
        <span class="co">-- Get the rendering cache from last </span>
        old <span class="fu">=</span> wsCache ws

    (fbw,fbh) <span class="ot">&lt;-</span> getFramebufferSize <span class="fu">$</span> rezWindow rz
    glViewport <span class="dv">0</span> <span class="dv">0</span> (fromIntegral fbw) (fromIntegral fbh)
    glClear <span class="fu">$</span> <span class="dt">GL_COLOR_BUFFER_BIT</span> <span class="fu">.|.</span> <span class="dt">GL_DEPTH_BUFFER_BIT</span>

    new <span class="ot">&lt;-</span> renderData rz old ui

    pollEvents
    swapBuffers <span class="fu">$</span> rezWindow rz
    shouldClose <span class="ot">&lt;-</span> windowShouldClose <span class="fu">$</span> rezWindow rz
    <span class="kw">if</span> shouldClose
    <span class="kw">then</span> exitSuccess
    <span class="kw">else</span> threadDelay <span class="dv">100</span>

    return <span class="fu">$</span> ws { wsCache <span class="fu">=</span> new }</code></pre></div>
<p>As you can see <a href="http://hackage.haskell.org/package/renderable-0.1.0.0/docs/src/Data.Renderable.html#renderData">renderData</a> pulls out the renderings we need from the old cache, creates the new ones, cleans the stale ones, renders your data and returns your new cache that you can use to render the next frame. This way if your interface never changes you don’t have to allocate any new resources - you shouldn’t even have to think about it.</p>
<h3 id="all-done">All done</h3>
<p>This is all a work in progress but I wanted to get these packages out to hopefully get some feedback before I settle on an API (I’ve already broken it once)! My next article will be about another project called <a href="http://hackage.haskell.org/package/gooey">gooey</a>. It’s a monadic layer on top of a previous FRP library I wrote called <a href="http://hackage.haskell.org/package/varying">varying</a>. I just realized how funny the <code>gooey</code> lib looks on hackage</p>
<div class="figure">
<img src="../img/Screenshot%202015-10-03%2020.42.39.png" alt="the gooey package" class=" img-responsive" />
<p class="caption">the gooey package</p>
</div>
<p>lol</p></div>
        </div>
      </div>
    </div>
    <!-- google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-47072737-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
