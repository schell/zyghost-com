<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <style type="text/css">
      h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
        font-family: Georgia, 'Times New Roman', serif;
      }
      /* syntax highlighting */
      table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre
         { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
      td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
      td.sourceCode { padding-left: 5px; }
      .sourceCode span.kw { color: #007020; font-weight: bold; }
      .sourceCode span.dt { color: #902000; }
      .sourceCode span.dv { color: #40a070; }
      .sourceCode span.bn { color: #40a070; }
      .sourceCode span.fl { color: #40a070; }
      .sourceCode span.ch { color: #4070a0; }
      .sourceCode span.st { color: #4070a0; }
      .sourceCode span.co { color: #60a0b0; font-style: italic; }
      .sourceCode span.ot { color: #007020; }
      .sourceCode span.al { color: red; font-weight: bold; }
      .sourceCode span.fu { color: #06287e; }
      .sourceCode span.re { }
      .sourceCode span.er { color: red; font-weight: bold; }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="page-header">
        <h1><a href="../">Zyghost</a> / Rendering text in Haskell using Freetype2 and OpenGL</h1>
        <a href="../articles.html">articles</a>
        &nbsp;
        &nbsp;
        <a href="https://github.com/schell"><i class="fa fa-github"></i></a>
        <a href="https://twitter.com/schellsan"><i class="fa fa-twitter"></i></a>
        <a href="https://instagram.com/schellsan/"><i class="fa fa-instagram"></i></a>
        <a href="https://www.facebook.com/likeaseashell"><i class="fa fa-facebook"></i></a>
      </div>

      <div class="row">
        <div class="content col-md-12">
          <h3 id="intro">Intro</h3>
<p>My last adventure in programming was using Haskell to hook up <a href="http://freetype.org/freetype2/">freetype2</a> to <a href="https://www.opengl.org/">OpenGL</a>. Freetype is a font rasterization library. The idea is that you use freetype to load a font and render it into an opengl texture, then render some font textured geometry in order to display strings of characters on the screen. The idea is simple enough but like many graphics projects there a a couple of gotchas that I bumped up against and dumped a significant amount of time into. I'm including code below to load a character into an OpenGL texture but I'm not including the surrounding code to render that texture. You should be able to use the loaded texture to draw a quad to see the character.</p>
<h3 id="setup">Setup</h3>
<p>So what I would like is a function that given a path to a ttf font file, a character and a pixel size - returns an opengl texture object that I can use to render a quad representing the character.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loadCharacter ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TextureObject</span>
loadCharacter path char px <span class="fu">=</span> undefined</code></pre></div>
<h3 id="freetype">Freetype</h3>
<p>The first step was to find some freetype2 bindings. Jason Dagit (lispy on #haskell irc) wrote some raw bindings that are on <a href="http://hackage.haskell.org/package/freetype2">hackage</a>. It works quite well and he has also posted an example of <a href="https://github.com/dagit/freetype2/blob/cabalization/Main.hs">rendering a string of characters as ascii images in a terminal</a>. Between that and the <a href="http://freetype.org/freetype2/docs/tutorial/step1.html">freetype2 tutorial</a> you should be able to get a good idea of the process behind rendering a font glyph into a freetype bitmap.</p>
<h4 id="helpers">Helpers</h4>
<p>Here we have some convenience functions. The first unboxes an IO FT_Error and fails if the FT_Error is non zero.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runFreeType ::</span> <span class="dt">IO</span> <span class="dt">FT_Error</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runFreeType m <span class="fu">=</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> m
    unless (r <span class="fu">==</span> <span class="dv">0</span>) <span class="fu">$</span> fail <span class="fu">$</span> <span class="st">&quot;FreeType Error:&quot;</span> <span class="fu">++</span> show r</code></pre></div>
<p>This code is simple enough. It arises from having to check almost every freetype operation for an error. None the less, I borrowed it from a package on hackage I found by checking the <a href="http://packdeps.haskellers.com/reverse">reverse package dependencies</a> on the freetype2 bindings and looking at the source of the <a href="http://hackage.haskell.org/package/free-game-0.9.4.3/docs/src/Graphics-UI-FreeGame-Data-Font.html#freeType">defunct free-game package</a>. This is one of the things that I love about Haskell. There are lots of high quality tools, resources and people to help you find the answers you need.</p>
<p>The next helper function allocs a c pointer for a FT_Library handle. This handle is needed for about half of the Freetype calls.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">freeType ::</span> <span class="dt">IO</span> <span class="dt">FT_Library</span>
freeType <span class="fu">=</span> alloca <span class="fu">$</span> \p <span class="ot">-&gt;</span> <span class="kw">do</span>
    runFreeType <span class="fu">$</span> ft_Init_FreeType p
    peek p</code></pre></div>
<p>Then we have a helper that given the <code>FT_Library</code> and a <code>FilePath</code> returns a loaded font face as a <code>FT_Face</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fontFace ::</span> <span class="dt">FT_Library</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">FT_Face</span>
fontFace ft fp <span class="fu">=</span> withCString fp <span class="fu">$</span> \str <span class="ot">-&gt;</span>
    alloca <span class="fu">$</span> \ptr <span class="ot">-&gt;</span> <span class="kw">do</span>
        runFreeType <span class="fu">$</span> ft_New_Face ft str <span class="dv">0</span> ptr
        peek ptr</code></pre></div>
<p>Lastly this function just gives us a string from a glyph format, FT_Glyph_Format, which we use when we output our glyph info.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">glyphFormatString ::</span> <span class="dt">FT_Glyph_Format</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
glyphFormatString fmt
    <span class="fu">|</span> fmt <span class="fu">==</span> ft_GLYPH_FORMAT_COMPOSITE <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_COMPOSITE&quot;</span>
    <span class="fu">|</span> fmt <span class="fu">==</span> ft_GLYPH_FORMAT_OUTLINE <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_OUTLINE&quot;</span>
    <span class="fu">|</span> fmt <span class="fu">==</span> ft_GLYPH_FORMAT_PLOTTER <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_PLOTTER&quot;</span>
    <span class="fu">|</span> fmt <span class="fu">==</span> ft_GLYPH_FORMAT_BITMAP <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_BITMAP&quot;</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_NONE&quot;</span></code></pre></div>
<h4 id="loading-a-freetype-bitmap">Loading a Freetype bitmap</h4>
<p>Here we have our <code>loadCharacter</code> function above - fleshed out for loading a glyph, rendering it into a Freetype bitmap and then printing some info about it to the console.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loadCharacter ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TextureObject</span>
loadCharacter path char px <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- FreeType (http://freetype.org/freetype2/docs/tutorial/step1.html)</span>
    ft <span class="ot">&lt;-</span> freeType

    <span class="co">-- Get the Ubuntu Mono fontface.</span>
    ff <span class="ot">&lt;-</span> fontFace ft path
    runFreeType <span class="fu">$</span> ft_Set_Pixel_Sizes ff (fromIntegral px) <span class="dv">0</span>

    <span class="co">-- Get the unicode char index.</span>
    chNdx <span class="ot">&lt;-</span> ft_Get_Char_Index ff <span class="fu">$</span> fromIntegral <span class="fu">$</span> fromEnum char

    <span class="co">-- Load the glyph into freetype memory.</span>
    runFreeType <span class="fu">$</span> ft_Load_Glyph ff chNdx <span class="dv">0</span>

    <span class="co">-- Get the GlyphSlot.</span>
    slot <span class="ot">&lt;-</span> peek <span class="fu">$</span> glyph ff

    <span class="co">-- Number of glyphs</span>
    n <span class="ot">&lt;-</span> peek <span class="fu">$</span> num_glyphs ff
    putStrLn <span class="fu">$</span> <span class="st">&quot;glyphs:&quot;</span> <span class="fu">++</span> show n

    fmt <span class="ot">&lt;-</span> peek <span class="fu">$</span> format slot
    putStrLn <span class="fu">$</span> <span class="st">&quot;glyph format:&quot;</span> <span class="fu">++</span> glyphFormatString fmt

    <span class="co">-- This is [] for Ubuntu Mono, but I'm guessing for bitmap</span>
    <span class="co">-- fonts this would be populated with the different font</span>
    <span class="co">-- sizes.</span>
    putStr <span class="st">&quot;Sizes:&quot;</span>
    numSizes <span class="ot">&lt;-</span> peek <span class="fu">$</span> num_fixed_sizes ff
    sizesPtr <span class="ot">&lt;-</span> peek <span class="fu">$</span> available_sizes ff
    sizes <span class="ot">&lt;-</span> forM [<span class="dv">0</span> <span class="fu">..</span> numSizes<span class="fu">-</span><span class="dv">1</span>] <span class="fu">$</span> \i <span class="ot">-&gt;</span>
        peek <span class="fu">$</span> sizesPtr <span class="ot">`plusPtr`</span> fromIntegral<span class="ot"> i ::</span> <span class="dt">IO</span> <span class="dt">BS.FT_Bitmap_Size</span>
    print sizes

    l <span class="ot">&lt;-</span> peek <span class="fu">$</span> bitmap_left slot
    t <span class="ot">&lt;-</span> peek <span class="fu">$</span> bitmap_top slot
    putStrLn <span class="fu">$</span> concat [ <span class="st">&quot;left:&quot;</span>
                      , show l
                      , <span class="st">&quot;\ntop:&quot;</span>
                      , show t
                      ]

    runFreeType <span class="fu">$</span> ft_Render_Glyph slot ft_RENDER_MODE_NORMAL

    <span class="co">-- Get the char bitmap.</span>
    bmp <span class="ot">&lt;-</span> peek <span class="fu">$</span> bitmap slot
    putStrLn <span class="fu">$</span> concat [<span class="st">&quot;width:&quot;</span>
                      , show <span class="fu">$</span> width bmp
                      , <span class="st">&quot; rows:&quot;</span>
                      , show <span class="fu">$</span> rows bmp
                      , <span class="st">&quot; pitch:&quot;</span>
                      , show <span class="fu">$</span> pitch bmp
                      , <span class="st">&quot; num_grays:&quot;</span>
                      , show <span class="fu">$</span> num_grays bmp
                      , <span class="st">&quot; pixel_mode:&quot;</span>
                      , show <span class="fu">$</span> pixel_mode bmp
                      , <span class="st">&quot; palette_mode:&quot;</span>
                      , show <span class="fu">$</span> palette_mode bmp
                      ]
    <span class="co">-- ...continued in the next section...</span></code></pre></div>
<p>Then the next problem is getting that bitmap into an OpenGL texture.</p>
<h3 id="opengl">OpenGL</h3>
<h4 id="first-try">First try</h4>
<p>Now that we have our glyph rendering into a freetype bitmap we can take that bitmap and buffer it into an OpenGL texture. The first step is to generate our texture name, activate it, etc - all the normal texture stuff.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- Generate an opengl texture.</span>
    [tex] <span class="ot">&lt;-</span> genObjectNames <span class="dv">1</span>
    texture <span class="dt">Texture2D</span> <span class="fu">$=</span> <span class="dt">Enabled</span>
    activeTexture     <span class="fu">$=</span> <span class="dt">TextureUnit</span> <span class="dv">0</span>
    textureBinding <span class="dt">Texture2D</span> <span class="fu">$=</span> <span class="dt">Just</span> tex
    printError</code></pre></div>
<p>Next we need buffer the data into the texture. We know from the freetype tutorial that the bitmap buffer is an array of 8bit chars representing a single channel of grayscale levels 0-255. We also already have a pointer to the data with <code>buffer bmp</code>. So we can use that info to set up our texImage2D to take the bitmap buffer from freetype directly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    putStrLn <span class="st">&quot;Buffering glyph bitmap into texture.&quot;</span>
    texImage2D
        <span class="dt">Texture2D</span>
        <span class="dt">NoProxy</span>
        <span class="dv">0</span>
        <span class="dt">R8</span>
        (<span class="dt">TextureSize2D</span> w' h')
        <span class="dv">0</span>
        (<span class="dt">PixelData</span> <span class="dt">Red</span> <span class="dt">UnsignedByte</span> <span class="fu">$</span> buffer bmp)
    printError

    putStrLn <span class="st">&quot;Texture loaded.&quot;</span></code></pre></div>
<p>Then we need to complete the texture by setting some filter parameters and return the texture name to end our function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="co">-- Complete the texture by setting some filtering parameters.</span>
    textureFilter   <span class="dt">Texture2D</span>   <span class="fu">$=</span> ((<span class="dt">Linear'</span>, <span class="dt">Nothing</span>), <span class="dt">Linear'</span>)
    textureWrapMode <span class="dt">Texture2D</span> <span class="dt">S</span> <span class="fu">$=</span> (<span class="dt">Repeated</span>, <span class="dt">ClampToEdge</span>)
    textureWrapMode <span class="dt">Texture2D</span> <span class="dt">T</span> <span class="fu">$=</span> (<span class="dt">Repeated</span>, <span class="dt">ClampToEdge</span>)

    return tex</code></pre></div>
<p>When you run that code you can either inspect your running OpenGL instance to see the buffered texture or you can draw a quad with it. If you set these filter parameters incorrectly or at the wrong time you'll still be able to see your texture in a profiler but OpenGL will consider it incomplete and will <em>not</em> render it. I found out that I was originally running into this problem because I was setting these params <em>before</em> I bound and buffered my texture. <a href="http://www.opengl.org/wiki/Common_Mistakes#Creating_a_complete_texture">This OpenGL wiki entry about incomplete textures helped me out</a>. After I figured that out my program spat out something that looked like</p>
<div class="figure">
<img src="../img/Screen%20Shot%202014-01-12%20at%2012.53.26%20PM.png" alt="a torn glyph" />
<p class="caption">a torn glyph</p>
</div>
<p>If you look closely you can see that there seems to be some noise at the bottom of the texture, which made me think that maybe OpenGL is reading past the end of the freetype buffer and getting some trash input. You can also see that the texture is obviously torn. With my settings of using Ubuntu Mono to render a Z at 251 pixels my loadCharacter function outputs</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">glyphs</span>:1296
<span class="kw">glyph</span> format:ft_GLYPH_FORMAT_OUTLINE
<span class="kw">Sizes</span>:[]
<span class="kw">left</span>:0
<span class="kw">top</span>:0
<span class="kw">width</span>:101 rows:155 pitch:101 num_grays:256 pixel_mode:2 palette_mode:0
<span class="kw">Buffering</span> glyph bitmap into texture.
<span class="kw">Texture</span> loaded.</code></pre></div>
<h4 id="fixing-the-tearing-with-padding">Fixing the tearing with padding</h4>
<p>I got stuck for a while trying to figure out what was causing the tearing. I thought it may be the pixel format, OpenGL's texture storage or whatever. I ended up just playing with the input to the <code>loadCharacter</code> function for a while to see how the tearing changed and eventually figured out that some of them rendered perfectly - like Ubuntu Mono at 270 pixels.</p>
<div class="figure">
<img src="../img/Screen%20Shot%202014-01-12%20at%201.01.58%20PM.png" alt="a perfect glyph" />
<p class="caption">a perfect glyph</p>
</div>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">glyphs</span>:1296
<span class="kw">glyph</span> format:ft_GLYPH_FORMAT_OUTLINE
<span class="kw">Sizes</span>:[]
<span class="kw">left</span>:0
<span class="kw">top</span>:0
<span class="kw">width</span>:108 rows:167 pitch:108 num_grays:256 pixel_mode:2 palette_mode:0
<span class="kw">Buffering</span> glyph bitmap into texture.
<span class="kw">Texture</span> loaded.</code></pre></div>
<p>The only difference I could see in the output info was that the width, rows and pitch were different, which makes sense because the bitmaps are different sizes. What I eventually figured out is that the latter's pitch is a multiple of four while the former's is not. Apparently (and forgive me if I'm wrong) but OpenGL likes texture widths that are divisible by four. So what I did was to change the buffering portion of <code>loadCharacter</code> to pad the texture every <code>width</code> pixels with some number of blank pixels to make the <code>width</code> a multiple of four.</p>
<p>First we need a pure padding function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addPadding ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
addPadding _ _ _ [] <span class="fu">=</span> []
addPadding amt w val xs <span class="fu">=</span> a <span class="fu">++</span> b <span class="fu">++</span> c
    <span class="kw">where</span> a <span class="fu">=</span> take w xs
          b <span class="fu">=</span> replicate amt val
          c <span class="fu">=</span> addPadding amt w val (drop w xs)</code></pre></div>
<p>Then we need to get our bitmap data into Haskell and pad it, then buffer that data into OpenGL.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">let</span> w  <span class="fu">=</span> fromIntegral <span class="fu">$</span> width bmp
        h  <span class="fu">=</span> fromIntegral <span class="fu">$</span> rows bmp
        w' <span class="fu">=</span> fromIntegral<span class="ot"> w ::</span> <span class="dt">Integer</span>
        h' <span class="fu">=</span> fromIntegral h
        p  <span class="fu">=</span> <span class="dv">4</span> <span class="fu">-</span> w <span class="ot">`mod`</span> <span class="dv">4</span>
        nw <span class="fu">=</span> p <span class="fu">+</span> fromIntegral w'

    putStrLn <span class="fu">$</span> <span class="st">&quot;padding by &quot;</span> <span class="fu">++</span> show p

    <span class="co">-- Get the raw bitmap data.</span>
    bmpData <span class="ot">&lt;-</span> peekArray (w<span class="fu">*</span>h) <span class="fu">$</span> buffer bmp

    <span class="kw">let</span> data' <span class="fu">=</span> addPadding p w <span class="dv">0</span> bmpData

    <span class="co">-- Generate an opengl texture.</span>
    [tex] <span class="ot">&lt;-</span> genObjectNames <span class="dv">1</span>
    texture <span class="dt">Texture2D</span> <span class="fu">$=</span> <span class="dt">Enabled</span>
    activeTexture     <span class="fu">$=</span> <span class="dt">TextureUnit</span> <span class="dv">0</span>
    textureBinding <span class="dt">Texture2D</span> <span class="fu">$=</span> <span class="dt">Just</span> tex
    printError

    putStrLn <span class="st">&quot;Buffering glyph bitmap into texture.&quot;</span>
    withArray data' <span class="fu">$</span> \ptr <span class="ot">-&gt;</span> texImage2D
        <span class="dt">Texture2D</span>
        <span class="dt">NoProxy</span>
        <span class="dv">0</span>
        <span class="dt">R8</span>
        (<span class="dt">TextureSize2D</span> (fromIntegral nw) h')
        <span class="dv">0</span>
        (<span class="dt">PixelData</span> <span class="dt">Red</span> <span class="dt">UnsignedByte</span> ptr)
    printError

    putStrLn <span class="st">&quot;Texture loaded.&quot;</span>
    textureFilter   <span class="dt">Texture2D</span>   <span class="fu">$=</span> ((<span class="dt">Linear'</span>, <span class="dt">Nothing</span>), <span class="dt">Linear'</span>)
    textureWrapMode <span class="dt">Texture2D</span> <span class="dt">S</span> <span class="fu">$=</span> (<span class="dt">Repeated</span>, <span class="dt">ClampToEdge</span>)
    textureWrapMode <span class="dt">Texture2D</span> <span class="dt">T</span> <span class="fu">$=</span> (<span class="dt">Repeated</span>, <span class="dt">ClampToEdge</span>)

    return tex</code></pre></div>
<p>Which gives us a perfectly rendered anti-aliased glyph.</p>
<div class="figure">
<img src="../img/Screen%20Shot%202014-01-12%20at%201.01.58%20PM.png" alt="a perfect glyph" />
<p class="caption">a perfect glyph</p>
</div>
<h4 id="fixing-it-with-row-alignment">Fixing it with row alignment</h4>
<p>Later thanks to reddit I found out that you can reset the row alignment in OpenGL with one call.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">rowAlignment <span class="dt">Unpack</span> <span class="fu">$=</span> <span class="dv">1</span></code></pre></div>
<p>This will change the default unpacking row alignment from 4 to 1 and fix our tearing issue.</p>
<h3 id="finally">Finally</h3>
<p>Altogether the code will look something like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Graphics.Text.Font</span> <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Control.Monad</span>
<span class="kw">import           </span><span class="dt">Graphics.Rendering.OpenGL</span> <span class="kw">hiding</span> (bitmap)
<span class="kw">import           </span><span class="dt">Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage</span>
<span class="kw">import           </span><span class="dt">Graphics.Rendering.FreeType.Internal</span>
<span class="kw">import           </span><span class="dt">Graphics.Rendering.FreeType.Internal.PrimitiveTypes</span>
<span class="kw">import           </span><span class="dt">Graphics.Rendering.FreeType.Internal.Library</span>
<span class="kw">import           </span><span class="dt">Graphics.Rendering.FreeType.Internal.FaceType</span>
<span class="kw">import           </span><span class="dt">Graphics.Rendering.FreeType.Internal.Face</span>
<span class="kw">import           </span><span class="dt">Graphics.Rendering.FreeType.Internal.GlyphSlot</span>
<span class="kw">import           </span><span class="dt">Foreign</span>
<span class="kw">import           </span><span class="dt">Foreign.C.String</span>
<span class="kw">import           </span><span class="dt">Graphics.Rendering.FreeType.Internal.Bitmap</span>
<span class="kw">import           </span><span class="dt">Graphics.Texture.Load</span>
<span class="kw">import           </span><span class="dt">Graphics.Utils</span>
<span class="kw">import qualified</span> <span class="dt">Graphics.Rendering.FreeType.Internal.BitmapSize</span> <span class="kw">as</span> <span class="dt">BS</span>

<span class="ot">loadCharacter ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TextureObject</span>
loadCharacter path char px texUnit <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- FreeType (http://freetype.org/freetype2/docs/tutorial/step1.html)</span>
    ft <span class="ot">&lt;-</span> freeType

    <span class="co">-- Get the Ubuntu Mono fontface.</span>
    ff <span class="ot">&lt;-</span> fontFace ft path
    runFreeType <span class="fu">$</span> ft_Set_Pixel_Sizes ff (fromIntegral px) <span class="dv">0</span>

    <span class="co">-- Get the unicode char index.</span>
    chNdx <span class="ot">&lt;-</span> ft_Get_Char_Index ff <span class="fu">$</span> fromIntegral <span class="fu">$</span> fromEnum char

    <span class="co">-- Load the glyph into freetype memory.</span>
    runFreeType <span class="fu">$</span> ft_Load_Glyph ff chNdx <span class="dv">0</span>

    <span class="co">-- Get the GlyphSlot.</span>
    slot <span class="ot">&lt;-</span> peek <span class="fu">$</span> glyph ff

    <span class="co">-- Number of glyphs</span>
    n <span class="ot">&lt;-</span> peek <span class="fu">$</span> num_glyphs ff
    putStrLn <span class="fu">$</span> <span class="st">&quot;glyphs:&quot;</span> <span class="fu">++</span> show n

    fmt <span class="ot">&lt;-</span> peek <span class="fu">$</span> format slot
    putStrLn <span class="fu">$</span> <span class="st">&quot;glyph format:&quot;</span> <span class="fu">++</span> glyphFormatString fmt

    <span class="co">-- This is [] for Ubuntu Mono, but I'm guessing for bitmap</span>
    <span class="co">-- fonts this would be populated with the different font</span>
    <span class="co">-- sizes.</span>
    putStr <span class="st">&quot;Sizes:&quot;</span>
    numSizes <span class="ot">&lt;-</span> peek <span class="fu">$</span> num_fixed_sizes ff
    sizesPtr <span class="ot">&lt;-</span> peek <span class="fu">$</span> available_sizes ff
    sizes <span class="ot">&lt;-</span> forM [<span class="dv">0</span> <span class="fu">..</span> numSizes<span class="fu">-</span><span class="dv">1</span>] <span class="fu">$</span> \i <span class="ot">-&gt;</span>
        peek <span class="fu">$</span> sizesPtr <span class="ot">`plusPtr`</span> fromIntegral<span class="ot"> i ::</span> <span class="dt">IO</span> <span class="dt">BS.FT_Bitmap_Size</span>
    print sizes

    l <span class="ot">&lt;-</span> peek <span class="fu">$</span> bitmap_left slot
    t <span class="ot">&lt;-</span> peek <span class="fu">$</span> bitmap_top slot
    putStrLn <span class="fu">$</span> concat [ <span class="st">&quot;left:&quot;</span>
                      , show l
                      , <span class="st">&quot;\ntop:&quot;</span>
                      , show t
                      ]

    runFreeType <span class="fu">$</span> ft_Render_Glyph slot ft_RENDER_MODE_NORMAL

    <span class="co">-- Get the char bitmap.</span>
    bmp <span class="ot">&lt;-</span> peek <span class="fu">$</span> bitmap slot
    putStrLn <span class="fu">$</span> concat [<span class="st">&quot;width:&quot;</span>
                      , show <span class="fu">$</span> width bmp
                      , <span class="st">&quot; rows:&quot;</span>
                      , show <span class="fu">$</span> rows bmp
                      , <span class="st">&quot; pitch:&quot;</span>
                      , show <span class="fu">$</span> pitch bmp
                      , <span class="st">&quot; num_grays:&quot;</span>
                      , show <span class="fu">$</span> num_grays bmp
                      , <span class="st">&quot; pixel_mode:&quot;</span>
                      , show <span class="fu">$</span> pixel_mode bmp
                      , <span class="st">&quot; palette_mode:&quot;</span>
                      , show <span class="fu">$</span> palette_mode bmp
                      ]

    <span class="kw">let</span> w  <span class="fu">=</span> fromIntegral <span class="fu">$</span> width bmp
        h  <span class="fu">=</span> fromIntegral <span class="fu">$</span> rows bmp
        w' <span class="fu">=</span> fromIntegral w
        h' <span class="fu">=</span> fromIntegral h

    <span class="co">-- Set the texture params on our bound texture.</span>
    texture <span class="dt">Texture2D</span> <span class="fu">$=</span> <span class="dt">Enabled</span>

    <span class="co">-- Set the alignment to 1 byte.</span>
    rowAlignment <span class="dt">Unpack</span> <span class="fu">$=</span> <span class="dv">1</span>

    <span class="co">-- Generate an opengl texture.</span>
    tex <span class="ot">&lt;-</span> newBoundTexUnit texUnit
    printError

    putStrLn <span class="st">&quot;Buffering glyph bitmap into texture.&quot;</span>
    texImage2D
        <span class="dt">Texture2D</span>
        <span class="dt">NoProxy</span>
        <span class="dv">0</span>
        <span class="dt">R8</span>
        (<span class="dt">TextureSize2D</span> w' h')
        <span class="dv">0</span>
        (<span class="dt">PixelData</span> <span class="dt">Red</span> <span class="dt">UnsignedByte</span> <span class="fu">$</span> buffer bmp)
    printError

    putStrLn <span class="st">&quot;Texture loaded.&quot;</span>
    textureFilter   <span class="dt">Texture2D</span>   <span class="fu">$=</span> ((<span class="dt">Linear'</span>, <span class="dt">Nothing</span>), <span class="dt">Linear'</span>)
    textureWrapMode <span class="dt">Texture2D</span> <span class="dt">S</span> <span class="fu">$=</span> (<span class="dt">Repeated</span>, <span class="dt">ClampToEdge</span>)
    textureWrapMode <span class="dt">Texture2D</span> <span class="dt">T</span> <span class="fu">$=</span> (<span class="dt">Repeated</span>, <span class="dt">ClampToEdge</span>)

    return tex


<span class="ot">addPadding ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
addPadding _ _ _ [] <span class="fu">=</span> []
addPadding amt w val xs <span class="fu">=</span> a <span class="fu">++</span> b <span class="fu">++</span> c
    <span class="kw">where</span> a <span class="fu">=</span> take w xs
          b <span class="fu">=</span> replicate amt val
          c <span class="fu">=</span> addPadding amt w val (drop w xs)


<span class="ot">glyphFormatString ::</span> <span class="dt">FT_Glyph_Format</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
glyphFormatString fmt
    <span class="fu">|</span> fmt <span class="fu">==</span> ft_GLYPH_FORMAT_COMPOSITE <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_COMPOSITE&quot;</span>
    <span class="fu">|</span> fmt <span class="fu">==</span> ft_GLYPH_FORMAT_OUTLINE <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_OUTLINE&quot;</span>
    <span class="fu">|</span> fmt <span class="fu">==</span> ft_GLYPH_FORMAT_PLOTTER <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_PLOTTER&quot;</span>
    <span class="fu">|</span> fmt <span class="fu">==</span> ft_GLYPH_FORMAT_BITMAP <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_BITMAP&quot;</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="st">&quot;ft_GLYPH_FORMAT_NONE&quot;</span>


<span class="ot">runFreeType ::</span> <span class="dt">IO</span> <span class="dt">FT_Error</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runFreeType m <span class="fu">=</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> m
    unless (r <span class="fu">==</span> <span class="dv">0</span>) <span class="fu">$</span> fail <span class="fu">$</span> <span class="st">&quot;FreeType Error:&quot;</span> <span class="fu">++</span> show r


<span class="ot">freeType ::</span> <span class="dt">IO</span> <span class="dt">FT_Library</span>
freeType <span class="fu">=</span> alloca <span class="fu">$</span> \p <span class="ot">-&gt;</span> <span class="kw">do</span>
    runFreeType <span class="fu">$</span> ft_Init_FreeType p
    peek p


<span class="ot">fontFace ::</span> <span class="dt">FT_Library</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">FT_Face</span>
fontFace ft fp <span class="fu">=</span> withCString fp <span class="fu">$</span> \str <span class="ot">-&gt;</span>
    alloca <span class="fu">$</span> \ptr <span class="ot">-&gt;</span> <span class="kw">do</span>
        runFreeType <span class="fu">$</span> ft_New_Face ft str <span class="dv">0</span> ptr
        peek ptr</code></pre></div>
<p>The code above contains some other helper functions that I haven't mentioned. You can find them in their respective modules at <a href="https://github.com/schell/editor/tree/glyph-rendering/src/Graphics">my github</a>.</p>
<h2 id="links-i-wish-i-had-before-i-wrote-this">Links I wish I had before I wrote this</h2>
<ul>
<li><a href="http://en.wikibooks.org/wiki/OpenGL_Programming/Modern_OpenGL_Tutorial_Text_Rendering_01">Text rendering OpenGL wikibook part 1</a></li>
<li><a href="http://en.wikibooks.org/wiki/OpenGL_Programming/Modern_OpenGL_Tutorial_Text_Rendering_02">Text rendering OpenGL wikibook part 2</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/3ddrawing/conceptual/opengles_programmingguide/WorkingwithEAGLContexts/WorkingwithEAGLContexts.html#//apple_ref/doc/uid/TP40008793-CH103-SW6">Rendering to a texture (for making an atlas)</a></li>
</ul>
        </div>
      </div>
    </div>
  </body>
</html>
